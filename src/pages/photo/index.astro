---
import HeaderAndFooter from "../../components/HeaderAndFooter/index.astro";
import Toggle from "../../components/Toggle/index.astro";
import { Img } from "astro-imagetools/components";
import exifr from "exifr";
import { Icon } from "astro-icon";
import sizeOf from "image-size";
import exiftoolJson from "../../../photo-portfolio/metadata.json";
import { renderImg } from "astro-imagetools/api";
import { writeFileSync } from "fs";
// import { defaultOG } from "../../components/HeaderAndFooter/index.astro";

// const defaultOGInfo = await defaultOG();

// console.log("exiftool", exiftoolJson["DSC05014.jpg"]);

const initialMode = Astro.props.initialMode || "gallery";

// const images = await Astro.glob("./portfolio/*").then((files) => {
//   console.log("files", files);
//   const out = {};
//   for (const file of files) {
//     const filename = file.default.split("/").pop().split("@")[0];
//     out[filename] = file;
//   }
//   return out;
// });

function removeEmpty(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
}

const cameraRenamings = {
  "SONY ILCE-7": "Sony a7",
  "NIKON CORPORATION NIKON D3200": "Nikon D3200",
  "DJI FC3682": "DJI Mini 3",
};

const lensRenamings = {
  "FE 28-70mm F3.5-5.6 OSS": "Sony FE 28-70mm",
  "18.0-105.0 mm f/3.5-5.6": "Nikkor 18-105mm DX",
  "AF-S DX VR Zoom-Nikkor 18-105mm f/3.5-5.6G ED": "Nikkor 18-105mm DX",
  "SAMYANG AF 24mm F2.8": "Rokinon 24mm f/2.8",
  "AF-S DX Nikkor 35mm f/1.8G": "Nikkor 35mm f/1.8G DX",
  "----": "Helios 44/2",
  "E 20-40mm F2.8 A062": "Tamron 20-40mm f/2.8",
};

function applyRenamings(str, renamings) {
  if (!str) {
    return str;
  }
  // console.log("str is", str);
  for (const [key, value] of Object.entries(renamings)) {
    if (!value) {
      return undefined;
    }
    str = str.replace(key, value);
  }
  return str;
}

const ogWidth = 1000;

const ogThumbs = {};

const glob = await import.meta.glob("/photo-portfolio/portfolio2k/*");
const images = {};
const icons = {};
await Promise.all(
  Object.keys(glob).map(async (path) => {
    // console.log("get exif from", path);
    const exif = await exifr.parse("." + path, {
      makerNote: true,
      userComment: true,
      xmp: true,
      icc: true,
      jfif: true,
    });
    const name = path.split("/").pop()?.split(".")[0];
    // const cleanName = decodeURIComponent(name.replaceAll("--", "%"));
    const { width, height } = await sizeOf("." + path);

    let { link, style, img } = await renderImg({
      src: path,
      breakpoints: [ogWidth],
      format: "webp",
      alt: "",
      quality: 50,
    });

    ogThumbs[name] = img
      .split('srcset="')[1]
      .split('"')[0]
      .replace("/_astro/", "");

    let im2 = await renderImg({
      src: path,
      breakpoints: [250],
      format: "webp",
      alt: "",
      quality: 50,
    });

    icons[name] = im2.img.split('srcset="')[1].split('"')[0];

    const extracted = {
      path,
      // ogImg: img.split('srcset="')[1].split('"')[0],
      ...removeEmpty(
        exif
          ? {
              latitude: exif.latitude,
              longitude: exif.longitude,
              aperture: exif.ApertureValue || exif.FNumber,
              shutter: exif.ExposureTime,
              iso: exif.ISO,
              focalLength: exif.FocalLengthIn35mmFormat || exif.FocalLength,
              camera:
                exif.Make &&
                exif.Model &&
                applyRenamings(exif.Make + " " + exif.Model, cameraRenamings),
              lens: applyRenamings(
                exif.LensModel ||
                  exif.Lens ||
                  (exiftoolJson[name] &&
                    (exiftoolJson[name]["Lens ID"] ||
                      exiftoolJson[name]["Lens Spec"])),
                lensRenamings
              ),
              date: exif.DateTimeOriginal || exif.CreateDate,
              width,
              height,
              decoded:
                exif.makerNode &&
                String.fromCharCode.apply(null, exif.makerNote),
            }
          : {}
      ),
    };
    // console.log(
    //   "decode",
    //   exif.makerNote,
    //   "to",
    //   String.fromCharCode.apply(null, exif.makerNote)
    // );
    // console.log("exif", exif, extracted);
    images[name] = extracted;
  })
);

// write ogThumbs to json file
// const fs = require("fs");
writeFileSync(
  "api/photo/.thumbs.js",
  `export default ${JSON.stringify(ogThumbs)}`
);

let minLat = Infinity;
let maxLat = -Infinity;
let minLng = Infinity;
let maxLng = -Infinity;

for (const [name, image] of Object.entries(images)) {
  if (image.latitude) {
    minLat = Math.min(minLat, image.latitude);
    maxLat = Math.max(maxLat, image.latitude);
    minLng = Math.min(minLng, image.longitude);
    maxLng = Math.max(maxLng, image.longitude);
    image.neighbor = Infinity;
    for (const [name2, image2] of Object.entries(images)) {
      if (image2.latitude && name != name2) {
        const dx = image2.longitude - image.longitude;
        const dy = image2.latitude - image.latitude;
        const dist = Math.sqrt(dx * dx + dy * dy);
        image.neighbor = Math.min(image.neighbor, dist);
      }
    }
  }
}

// for (const path of Object.keys(glob)) {
//   const filename = path.split("/").pop().split("@")[0];
//   images[filename] = glob[path];
// }

// console.log("exif", imageExif);
// console.log("first buffer", await images[imageNames[0]]());
// console.log("images", images);
const gutter = 10;
const title = "Photography";
const description =
  "My highly-interactive portfolio of artistic photographs captured and developed since 2014.";
---

<HeaderAndFooter
  allowMainStyles
  mainClass={initialMode}
  color="#eeeeeed0"
  themeColor="#f0f0f0"
  darkText
  hoverZoneBehind
  title={title}
  description={description}
>
  <h1>Photography</h1>
  <p>
    My enthusiasm for capturing photographs lends me a creative release from my
    logical, algorithmic side. It also enables me to truly admire the
    compositional beauty in front of my eyes every day, from San Francisco, to
    Venice, to my own backyard.
  </p>
  <Toggle
    actions={[
      {
        id: "galleryButton",
        label: "Gallery",
      },
      {
        id: "mapButton",
        label: "Map",
      },
    ]}
    defaultAction={initialMode == "gallery" ? "galleryButton" : "mapButton"}
    id="photoToggle"
  />
  <div id="advancedLabel">AI search via Zero-Shot Image Classification</div>
  <div id="AISearch" class="minimized">
    <input
      type="text"
      placeholder="Model still mounting..."
      disabled="disabled"
    />
  </div>
  <div id="photoContent">
    <div id="gallery">
      {
        Object.entries(images).map(([name, image]) => (
          <div class="galleryImage" name={name}>
            <Img
              src={image.path}
              alt=""
              breakpoints={[600]}
              quality={50}
              format="webp"
              saturation={1.1}
              placeholder="dominantColor"
              loading="lazy"
            />
            {image.latitude && (
              <Icon pack="mdi" name="map-marker" color="white" />
            )}
          </div>
        ))
      }
    </div>
    <div id="map">
      <div id="exploreMap"></div>
    </div>
    <div class="fullScreenReserves">
      {
        Object.entries(images).map(([name, image]) => (
          <div id={`fullScreen-${name}`} class="full">
            <Img
              src={image.path}
              alt=""
              breakpoints={[400, 800, 1200, 1600, 2000]}
              quality={60}
              format="webp"
              placeholder="blurred"
              loading="lazy"
              saturation={1.1}
            />
          </div>
        ))
      }
    </div>
    <!-- <div class="thumbnailReserves">
      {
        Object.entries(images).map(([name, image]) => (
          <div id={`thumbnail-${name}`} class="thumb">
            <Img
              src={image.path}
              alt=""
              breakpoints={[300]}
              quality={50}
              format="webp"
              saturation={1.1}
              placeholder="blurred"
              loading="lazy"
            />
          </div>
        ))
      }
    </div> -->
  </div>

  <div id="fullScreen" slot="topLevel">
    <div class="section" id="photoFullScreen">
      <div id="imageInfo">
        <div id="imageName">image name</div>
        <div id="metaData">
          <div>10s</div>
          <div>f2.8</div>
        </div>
        <div id="fullScreenActions">
          <div id="prev">Prev</div>
          <div id="next">Next</div>
          <div id="exit">Exit</div>
        </div>
      </div>
    </div>
    <div class="section" id="mapFullScreen">
      <div id="selectedMap"></div>
    </div>
  </div>

  {
    initialMode == "map" ? (
      <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyACmDd88Pi1CAoU8Q4keEPKzc1RzqIkCuw&v=3.exp"
        id="mapsScript"
      />
    ) : (
      <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyACmDd88Pi1CAoU8Q4keEPKzc1RzqIkCuw&v=3.exp"
        id="mapsScript"
        defer
      />
    )
  }

  {
    initialMode == "gallery" ? (
      <script
        src="https://masonry.desandro.com/masonry.pkgd.js"
        id="masonryScript"
      />
    ) : (
      <script
        src="https://masonry.desandro.com/masonry.pkgd.js"
        id="masonryScript"
        defer
      />
    )
  }

  <style
    define:vars={{
      gutter: gutter + "px",
    }}
  >
    :global(#photoToggle) {
      margin-bottom: 1em;
    }
    #advancedLabel {
      font-size: 0.8em;
      opacity: 0.5;
      margin-bottom: 1em;
      cursor: pointer;
      transition: opacity 0.2s ease;
      display: none;
    }

    /* :global(.modeMap) #advancedLabel, :global(.modeMap) #AISearch {
      display: none;
    } */

    #advancedLabel:hover {
      opacity: 1;
    }

    #AISearch {
      width: 100%;
      max-width: 500px;
      height: 2.4em;
      transition: all 0.15s ease;
      padding-bottom: 1em;
      box-sizing: content-box;
      display: none;
    }

    #AISearch.minimized {
      height: 0;
      padding: 0;
      opacity: 0;
    }

    #AISearch > input {
      width: 100%;
      height: 100%;
      padding: 0 1em;
      font-size: 1em;
      border: none;
      outline: none;
      box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.1);
      border-radius: 8px;
    }

    #photoContent > div {
      display: none;
      width: 100%;
    }

    /* img {
      color: transparent !important;
      text-indent: 100%;
      white-space: nowrap;
      overflow: hidden;
    } */

    /* img:first {
      postition: absolute;
      left: -9999px;
      top: -9999px;
      z-index: -100;
    } */
    /* :global(main.gallery) #photoContent > #gallery {
      display: block;
    } */

    #photoContent {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      position: relative;
      max-width: none;
    }

    .galleryImage {
      position: relative;
      /* width: calc(50% - var(--gutter) / 2); */
      margin-bottom: var(--gutter);
      cursor: pointer;
    }

    .galleryImage > svg {
      position: absolute;
      bottom: 5px;
      right: 5px;
      width: 25px;
      opacity: 0.7;
    }

    #exploreMap {
      width: 100%;
      height: calc(100vh - 70px);
      /* background-color: pink; */
    }

    .thumb {
      width: 192px;
      border: 8px solid white;
      /* height: 100px; */
    }

    :global(div[role="dialog"], div[role="dialog"] *) {
      padding: 0 !important;
      overflow: hidden !important;
      border-radius: 0 !important;
      box-shadow: none !important;
    }

    :global(.gm-ui-hover-effect) {
      display: none !important;
    }

    #fullScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      max-width: none;
      height: 100dvh;
      background-color: white;
      /* border: 10px solid yellow; */
      z-index: 9999999;
      overflow: scroll;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s ease;
    }
    #fullScreen.active {
      opacity: 1;
      pointer-events: all;
    }

    #fullScreen .section {
      height: 100vh;
      height: 100dvh;
      width: 100%;
      /* border: 10px solid yellow; */
      padding: var(--gutter);
    }

    #photoFullScreen {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #imageInfo {
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* flex: 1; */
    }

    #imageName {
      font-size: 1.2em;
      margin-bottom: 0.2em;
      text-align: center;
    }

    #metaData,
    #fullScreenActions {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }

    :global(#map div[role="button"] > img) {
      /* border: 2px solid white !important; */
    }

    :global(#metaData > div) {
      margin: 0.3em;
      font-size: 0.9em;
      padding: 0.2em 0.5em;
      background-color: rgba(0, 0, 0, 0.04);
      color: #888;
      border-radius: 0.3em;
      white-space: nowrap;
    }

    #fullScreenActions > div {
      padding: 0.2em 0.5em;
      opacity: 0.4;
      transition: opacity 0.2s ease;
      cursor: pointer;
    }

    #fullScreenActions > div:hover {
      opacity: 1;
    }

    #photoFullScreen .full {
    }

    #selectedMap {
      height: 100%;
      width: 100%;
    }

    :global(.stop-scrolling) {
      height: 100%;
      overflow: hidden;
    }
    :global(.navHoverZone) {
      backdrop-filter: none;
      background-color: white;
    }

    @media screen and (max-width: 600px) {
      #photoContent {
        width: calc(100vw - var(--gutter) * 2);
      }
    }

    :global(.mapThumb) {
      position: absolute;
      transform: translate(-50%, -100%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      box-shadow: 0 10px 30px 0 rgba(0, 0, 0, 0.2);
      background-color: white;
      border-radius: 3px;
    }

    :global(.mapThumb p) {
      position: absolute;
      background-color: rgb(255, 255, 255);
      text-indent: 0 !important;
      padding: 0em 0.3em !important;
      /* transform: translate(-6px, -6px); */
      border-bottom-right-radius: 0.4em;
      border-top-left-radius: 3px;
      color: black !important;
      font-size: 0.8rem !important;
      font-weight: 1000;
    }

    :global(.mapThumb.visible) {
      opacity: 1 !important;
      pointer-events: all !important;
    }

    :global(.mapThumb img) {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 3px solid white;
      border-radius: 3px;
    }

    :global(.mapThumb svg) {
      position: absolute;
      width: 20px;
      height: 20px;
      bottom: 0;
      left: 50%;
      transform-origin: bottom center;
      transform: translateX(-50%) scale(0.4) translateY(10px);
      overflow: visible;
    }
    :global(.mapThumb svg path) {
      stroke-width: 10;
      stroke: white;
      stroke-linejoin: round;
      stroke-linecap: round;
    }
  </style>

  <script
    define:vars={{
      initialMode: initialMode,
      gutter: gutter,
      images: images,
      minLat: minLat,
      maxLat: maxLat,
      minLng: minLng,
      maxLng: maxLng,
      icons: icons,
      // ogWidth: ogWidth,
      // defaultOGInfo: defaultOGInfo,
      // title: title + " | Blake Sanie",
      // description: description,
    }}
  >
    let fullScreenElement;
    let photoFullScreenElement;
    let mapFullScreenElement;
    let imageInfoElement;
    let imageNameElement;
    let metaDataElement;
    let prevElement;
    let nextElement;
    let fullScreenOpen = false;
    let openFileName;
    let selectedMapElement;

    let currentImageElement;

    //  __                            __
    // /  |                          /  |
    // $$ |  ______    ______    ____$$ |        ______   __    __   ______    ______   __    __
    // $$ | /      \  /      \  /    $$ |       /      \ /  |  /  | /      \  /      \ /  |  /  |
    // $$ |/$$$$$$  | $$$$$$  |/$$$$$$$ |      /$$$$$$  |$$ |  $$ |/$$$$$$  |/$$$$$$  |$$ |  $$ |
    // $$ |$$ |  $$ | /    $$ |$$ |  $$ |      $$ |  $$ |$$ |  $$ |$$    $$ |$$ |  $$/ $$ |  $$ |
    // $$ |$$ \__$$ |/$$$$$$$ |$$ \__$$ |      $$ \__$$ |$$ \__$$ |$$$$$$$$/ $$ |      $$ \__$$ |
    // $$ |$$    $$/ $$    $$ |$$    $$ |      $$    $$ |$$    $$/ $$       |$$ |      $$    $$ |
    // $$/  $$$$$$/   $$$$$$$/  $$$$$$$/        $$$$$$$ | $$$$$$/   $$$$$$$/ $$/        $$$$$$$ |
    //                                               $$ |                              /  \__$$ |
    //                                               $$ |                              $$    $$/
    //                                               $$/                                $$$$$$/

    function getUrlQuery() {
      var search = location.search.substring(1);
      if (!search) {
        return {};
      }
      return JSON.parse(
        '{"' +
          search
            .replace(/"/g, '\\"')
            .replace(/&/g, '","')
            .replace(/=/g, '":"') +
          '"}'
      );
    }

    const initialUrlQuery = location.search
      ? getUrlQuery().im
      : location.pathname
          .replace("/photo/map", "")
          .replace("/photo", "")
          .substring(1); // get rid one leading slash

    if (initialUrlQuery) {
      let initialQueryInterval;
      const initialFilename = initialUrlQuery;
      // console.log("initialFilename", initialFilename);
      function initialFullScreen() {
        try {
          activateFullScreen(initialFilename);
          clearInterval(initialQueryInterval);
        } catch {}
      }
      initialQueryInterval = setInterval(initialFullScreen, 10);
      initialFullScreen();
    }

    //  __
    // /  |
    // $$/  _____  ____    ______          ______    ______    _______
    // /  |/     \/    \  /      \        /      \  /      \  /       |
    // $$ |$$$$$$ $$$$  |/$$$$$$  |      /$$$$$$  |/$$$$$$  |/$$$$$$$/
    // $$ |$$ | $$ | $$ |$$ |  $$ |      $$ |  $$ |$$ |  $$ |$$      \
    // $$ |$$ | $$ | $$ |$$ \__$$ |      $$ \__$$ |$$ |__$$ | $$$$$$  |
    // $$ |$$ | $$ | $$ |$$    $$ |      $$    $$/ $$    $$/ /     $$/
    // $$/ $$/  $$/  $$/  $$$$$$$ |       $$$$$$/  $$$$$$$/  $$$$$$$/
    //                   /  \__$$ |                $$ |
    //                   $$    $$/                 $$ |
    //                    $$$$$$/                  $$/

    const galleryContainer = document.getElementById("gallery");

    // do the shuffling regardless
    let imageChanges = {};

    function setImageOrder() {
      let imageOrder = [];

      for (var i = 0; i < galleryContainer.children.length; i++) {
        const name = galleryContainer.children[i].getAttribute("name");
        imageOrder.push(name);
        galleryContainer.children[i].addEventListener("click", () => {
          activateFullScreen(name);
        });
      }

      imageChanges = {};
      let prev = undefined;
      for (let i = 0; i < imageOrder.length; i++) {
        const curr = imageOrder[i];
        if (prev) {
          imageChanges[prev]["next"] = curr;
        }
        imageChanges[curr] = {
          prev: prev,
        };
        prev = curr;
      }
    }

    function shuffleImgElements() {
      for (var i = galleryContainer.children.length; i >= 0; i--) {
        const index = Math.random() * i;
        galleryContainer.appendChild(galleryContainer.children[index | 0]);
      }

      setImageOrder();
    }

    shuffleImgElements();

    // console.log("image changes", imageChanges);

    //                                __
    //                               /  |
    //  _____  ____    ______    ____$$ |  ______
    // /     \/    \  /      \  /    $$ | /      \
    // $$$$$$ $$$$  |/$$$$$$  |/$$$$$$$ |/$$$$$$  |
    // $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$    $$ |
    // $$ | $$ | $$ |$$ \__$$ |$$ \__$$ |$$$$$$$$/
    // $$ | $$ | $$ |$$    $$/ $$    $$ |$$       |
    // $$/  $$/  $$/  $$$$$$/   $$$$$$$/  $$$$$$$/

    let mode = initialMode;

    const galleryButton = document.getElementById("galleryButton");
    const mapButton = document.getElementById("mapButton");

    const mapContainer = document.getElementById("map");

    galleryButton?.addEventListener("click", () => {
      if (mode != "gallery") {
        mode = "gallery";
        document.getElementById("photoNavLink").click();
        history.replaceState({}, null, "/photo");
        activateGallery();
      }
    });
    mapButton?.addEventListener("click", () => {
      if (mode != "map") {
        mode = "map";
        document.getElementById("mapNavLink").click();
        history.replaceState({}, null, "/photo/map");
        activateMap();
      }
    });

    let msnry;

    let resizedSinceSwitchedToMap = false;

    function activateGallery(reset = false) {
      document.querySelector("body").classList.add("modeGallery");
      document.querySelector("body").classList.remove("modeMap");
      function showGallery() {
        mapContainer.style.display = "none";
        galleryContainer.style.display = "block";
        document.getElementById("advancedLabel").style.display = "block";
        document.getElementById("AISearch").style.display = "block";
        // history.pushState({}, null, "/photo");
      }
      function getImageWidth() {
        const usableWidth = galleryContainer.clientWidth;
        let numCols = Math.floor(Math.pow(usableWidth, 0.6) / 18);
        return usableWidth / numCols - (gutter * (numCols - 1)) / numCols - 0.5;
      }

      function setGalleryImageWidths() {
        if (mode == "map") {
          resizedSinceSwitchedToMap = true;
          // console.log("resized since switch to map", resizedSinceSwitchedToMap);
          return;
        }
        const width = getImageWidth();
        // console.log("new image width", width);
        const images = document.getElementsByClassName("galleryImage");
        for (let i = 0; i < images.length; i++) {
          images[i].style.width = width + "px";
        }
      }
      if (!msnry || reset) {
        if (!reset) {
          showGallery();

          window.addEventListener("resize", setGalleryImageWidths);
        }
        setGalleryImageWidths();

        // gallery.style.opacity = 0;
        if (msnry) {
          msnry.destroy();
        }
        msnry = new Masonry("#gallery", {
          columnWidth: ".galleryImage",
          itemSelector: ".galleryImage",
          gutter: gutter,
          transitionDuration: 200,
        });
        if (!reset) {
          msnry.on("layoutComplete", function () {
            galleryContainer.style.opacity = 1;
            // console.log("layout complete");
          });
        }
        // console.log("masonry", msnry);
      } else {
        if (resizedSinceSwitchedToMap) {
          galleryContainer.style.opacity = 0;
        }

        showGallery();
        if (resizedSinceSwitchedToMap) {
          // console.log("RESIZE AFTER SWITCH");
          setGalleryImageWidths();
          msnry.layout();
          resizedSinceSwitchedToMap = false;
        }
      }
    }

    let map;
    let blurInterval;

    let drawReady = false;

    function activateMap() {
      resizedSinceSwitchedToMap = false;
      document.querySelector("body").classList.remove("modeGallery");
      document.querySelector("body").classList.add("modeMap");
      function showMap() {
        galleryContainer.style.display = "none";
        mapContainer.style.display = "block";
        document.getElementById("advancedLabel").style.display = "none";
        document.getElementById("AISearch").style.display = "none";
        // history.pushState({}, null, "/photo/map");
      }

      showMap();

      class Popup extends google.maps.OverlayView {
        position;
        name;
        image;
        containerDiv;
        map;
        width;
        height;
        covering;
        constructor(name, image, map) {
          super();
          this.position = new google.maps.LatLng(
            image.latitude,
            image.longitude
          );
          this.name = name;
          this.image = image;
          // This zero-height div is positioned at the bottom of the bubble.
          const img = document.createElement("img");
          img.src = icons[name];
          img.classList.add("mapImg");
          // This zero-height div is positioned at the bottom of the tip.
          this.containerDiv = document.createElement("div");
          this.containerDiv.classList.add("mapThumb");
          const area = 7000;
          const fullArea = image.width * image.height;
          const scalar = 1 / Math.sqrt(fullArea / area);
          this.width = image.width * scalar;
          this.height = image.height * scalar;
          this.containerDiv.style.width = this.width + "px";
          this.containerDiv.style.height = this.height + "px";

          const label = document.createElement("p");

          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg"
          );
          svg.setAttribute("viewbox", "0 0 20 20");
          svg.setAttribute("width", "20px");
          svg.setAttribute("height", "20px");
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute("d", "M 10,18 2,5 18,5 z");
          svg.appendChild(path);

          this.containerDiv.appendChild(svg);
          this.containerDiv.appendChild(img);
          this.containerDiv.appendChild(label);
          // Optionally stop clicks, etc., from bubbling up to the map.
          Popup.preventMapHitsAndGesturesFrom(this.containerDiv);
          this.map = map;
          this.setMap(map);
          this.count = 1;
        }
        /** Called when the popup is added to the map. */
        onAdd() {
          this.getPanes().floatPane.appendChild(this.containerDiv);
        }
        /** Called when the popup is removed from the map. */
        onRemove() {
          if (this.containerDiv.parentElement) {
            this.containerDiv.parentElement.removeChild(this.containerDiv);
          }
        }

        getBox() {
          const divPosition = this.getProjection().fromLatLngToDivPixel(
            this.position
          );
          return [
            divPosition.x - this.width / 2,
            divPosition.y - this.height,
            divPosition.x + this.width / 2,
            divPosition.y,
          ];
        }
        setVisibility(visible) {
          if (visible) {
            this.containerDiv.classList.add("visible");
          } else {
            this.containerDiv.classList.remove("visible");
          }
        }
        /** Called each frame when the popup needs to draw itself. */
        draw() {
          const divPosition = this.getProjection().fromLatLngToDivPixel(
            this.position
          );
          // if (!drawReady) {
          //   drawReady = true;
          //   if (this.visibilityFunc) {
          //     console.log("DRAW READY");
          //     this.visibilityFunc();
          //   }
          // }
          // Hide the popup when it is far out of view.
          // const display =
          //   Math.abs(divPosition.x) < window.innerWidth / 2 + 100 &&
          //   Math.abs(divPosition.y) < window.innerHeight / 2 + 100
          //     ? "block"
          //     : "none";

          // if (display === "block") {
          this.containerDiv.style.left = divPosition.x + "px";
          this.containerDiv.style.top = divPosition.y + "px";
          // }

          // if (this.containerDiv.style.display !== display) {
          //   this.containerDiv.style.display = display;
          // }
        }
      }

      const width = mapContainer.clientWidth;
      const zoom = Math.floor(1.73 * Math.log(width) - 9.26);

      if (!map) {
        map = new google.maps.Map(document.getElementById("exploreMap"), {
          center: {
            lat: (maxLat + minLat) / 2,
            lng: (maxLng + minLng) / 2,
          },
          zoom: zoom,
          zoomControl: true,
          zoomControlOptions: {
            position: google.maps.ControlPosition.RIGHT_CENTER,
          },
          streetViewControl: true,
          streetViewControlOptions: {
            position: google.maps.ControlPosition.RIGHT_CENTER,
          },
          fullscreenControl: true,
          fullscreenControlOptions: {
            position: google.maps.ControlPosition.RIGHT_CENTER,
          },
          rotateControl: true,
          rotateControlOptions: {
            position: google.maps.ControlPosition.RIGHT_CENTER,
          },
          styles: [
            {
              elementType: "geometry",
              stylers: [
                {
                  color: "#ffffff",
                },
              ],
            },
            {
              elementType: "labels.icon",
              stylers: [
                {
                  visibility: "off",
                },
              ],
            },
            {
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#616161",
                },
              ],
            },
            {
              elementType: "labels.text.stroke",
              stylers: [
                {
                  color: "#f5f5f5",
                },
              ],
            },
            {
              featureType: "administrative.land_parcel",
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#bdbdbd",
                },
              ],
            },
            {
              featureType: "administrative.province",
              elementType: "geometry.stroke",
              stylers: [
                {
                  color: "#9e9e9e",
                },
              ],
            },
            {
              featureType: "landscape.natural.terrain",
              stylers: [
                {
                  color: "#c9c9c9",
                },
              ],
            },
            {
              featureType: "poi",
              elementType: "geometry",
              stylers: [
                {
                  color: "#f5f5f5",
                },
              ],
            },
            {
              featureType: "poi",
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#757575",
                },
              ],
            },
            {
              featureType: "poi.park",
              elementType: "geometry",
              stylers: [
                {
                  color: "#ededed",
                },
              ],
            },
            {
              featureType: "poi.park",
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#b0b0b0",
                },
              ],
            },
            {
              featureType: "road",
              elementType: "geometry",
              stylers: [
                {
                  visibility: "simplified",
                },
              ],
            },
            {
              featureType: "road",
              elementType: "geometry.stroke",
              stylers: [
                {
                  color: "#f2f2f2",
                },
                {
                  visibility: "on",
                },
              ],
            },
            {
              featureType: "road.arterial",
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#757575",
                },
              ],
            },
            {
              featureType: "road.highway",
              elementType: "geometry",
              stylers: [
                {
                  color: "#e6e6e6",
                },
              ],
            },
            {
              featureType: "road.highway",
              elementType: "geometry.stroke",
              stylers: [
                {
                  visibility: "simplified",
                },
              ],
            },
            {
              featureType: "road.highway",
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#616161",
                },
              ],
            },
            {
              featureType: "road.local",
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#9e9e9e",
                },
              ],
            },
            {
              featureType: "transit.line",
              elementType: "geometry",
              stylers: [
                {
                  color: "#e5e5e5",
                },
              ],
            },
            {
              featureType: "transit.station",
              elementType: "geometry",
              stylers: [
                {
                  color: "#eeeeee",
                },
              ],
            },
            {
              featureType: "water",
              elementType: "geometry",
              stylers: [
                {
                  color: "#c9c9c9",
                },
              ],
            },
            {
              featureType: "water",
              elementType: "geometry.fill",
              stylers: [
                {
                  color: "#c7e9ff",
                },
              ],
            },
            {
              featureType: "water",
              elementType: "labels.text.fill",
              stylers: [
                {
                  color: "#9e9e9e",
                },
              ],
            },
          ],
        });
        const infoWindow = new google.maps.InfoWindow();

        // let i = 1;
        const markers = [];
        for (const [name, image] of Object.entries(images)) {
          if (!image.latitude) {
            continue;
          }
          // const area = 3000;
          // const fullArea = image.width * image.height;
          // const scalar = 1 / Math.sqrt(fullArea / area);

          // const marker = new google.maps.Marker({
          //   position: { lat: lat, lng: lng },
          //   map: map,
          //   zIndex: 1,
          //   icon: {
          //     url: icons[name],
          //     // size: new google.maps.Size(40, 40),
          //     scaledSize: new google.maps.Size(
          //       image.width * scalar,
          //       image.height * scalar
          //     ),
          //   },
          // });
          const marker = new Popup(name, image, map);
          markers.push(marker);

          // const borderWidth = 2;

          // const bgWidth = image.width * scalar + borderWidth * 2;
          // const bgHeight = image.height * scalar + borderWidth * 2;

          // const markerBg = new google.maps.Marker({
          //   position: { lat: lat, lng: lng },
          //   map: map,
          //   zIndex: i,
          //   icon: {
          //     url:
          //       "data:image/svg+xml," +
          //       encodeURIComponent(
          //         `<svg xmlns="http://www.w3.org/2000/svg" width="${bgWidth}" height="${bgHeight}" viewBox="0 0 ${bgWidth} ${bgHeight}">` +
          //           `<rect x="0" y="0" width="${bgWidth}" height="${bgHeight}" fill="white" stroke="white" stroke-width="2"/>` +
          //           "</svg>"
          //       ),
          //     // size: new google.maps.Size(40, 40),
          //     scaledSize: new google.maps.Size(bgWidth, bgHeight),
          //   },
          // });

          // function showPreview() {
          //   const element = document
          //     .getElementById("thumbnail-" + name)
          //     .cloneNode(true);
          //   console.log("cloned thumb", element);
          //   infoWindow.setContent(element);
          //   infoWindow.open(marker.getMap(), marker);
          // }

          // marker.addListener("mouseover", function (e) {
          //   marker.setOptions({ zIndex: 99999 });
          //   showPreview();
          // });
          // marker.addListener("mouseout", function () {
          //   marker.setOptions({ zIndex: 1 });
          //   infoWindow.close();
          // });
          // marker.addListener("click", (e) => {
          //   if (image.neighbor) {
          //     const zoom = map.zoom;
          //     const idealZoom = Math.round(
          //       -Math.log10(image.neighbor) / 0.3 + 7
          //     );
          //     console.log("zooms", zoom, idealZoom);
          //     if (zoom < idealZoom) {
          //       map.setCenter({
          //         lat: lat,
          //         lng: lng,
          //       });
          //       map.setZoom(Math.max(1 + zoom, zoom * 0.25 + 0.75 * idealZoom));
          //       return;
          //     }
          //   }
          //   blurInterval = setInterval(() => {
          //     document.activeElement.blur();
          //   }, 100);
          //   activateFullScreen(name);
          //   e.domEvent.stopPropagation();
          //   e.domEvent.preventDefault();
          //   console.log("active before", document.activeElement);
          //   document.activeElement.blur();
          //   console.log("active after", document.activeElement);
          //   // console.log("click event", e.domEvent);
          // });
          // i += 2;
        }
        // const projection = map.getProjection();
        // console.log("projection", projection);
        google.maps.event.addListener(map, "idle", function () {
          updateVisibilities();
        });
        google.maps.event.addListener(map, "zoom_changed", function () {
          // console.log("zoom", map.zoom);
          updateVisibilities();
        });

        const zoomVisibilities = {};

        function applyVisibilities(covers) {
          for (let i = 0; i < markers.length; i++) {
            const covered = covers[i];
            markers[i].setVisibility(covered);
            if (covered && covered.length > 0) {
              markers[i].containerDiv.querySelector("p").textContent =
                covered.length + 1;
            } else {
              markers[i].containerDiv.querySelector("p").textContent = "";
            }
          }
        }

        function boxToZoom(latRange, lngRange) {
          function toZoom(range, size) {
            // console.log("lng range", range);
            // debugger;
            // 400 -1 adjustment
            // 700 perfect
            const base = -Math.log10(range) / 0.35 + 8.9;
            const adjustment = Math.min(0, (-1 / 300) * (700 - size));
            return base + adjustment;
          }
          // return toZoom(lngRange, mapContainer.clientWidth);
          return Math.max(
            map.zoom + 1,
            Math.min(
              toZoom(latRange, mapContainer.clientHeight),
              toZoom(lngRange, mapContainer.clientWidth)
            )
          );
        }

        let i = 0;
        for (const marker of markers) {
          const index = i;
          marker.containerDiv.id = "mapThumb-" + i;
          marker.containerDiv.addEventListener("click", function () {
            // Handle click event here
            const covered = zoomVisibilities[map.zoom][index];
            if (covered) {
              if (covered.length == 0) {
                activateFullScreen(marker.name);
                return;
              }
              let minLat = marker.position.lat();
              let maxLat = minLat;
              let minLng = marker.position.lng();
              let maxLng = minLng;
              for (const j of covered) {
                const pos = markers[j].position;
                const lat = pos.lat();
                const lng = pos.lng();
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
              }
              map.setCenter({
                lat: (maxLat + minLat) / 2,
                lng: (maxLng + minLng) / 2,
              });
              map.setZoom(boxToZoom(maxLat - minLat, maxLng - minLng));
              updateVisibilities();
            }

            // covering;
          });
          i++;
        }

        let prevZoom = map.zoom;

        function updateVisibilities() {
          // debugger;
          // let covers = zoomVisibilities[map.zoom];
          // if (covers) {
          //   applyVisibilities(covers);
          //   return;
          // }
          // debugger;
          let visibleIndices = [];
          // for (let i = map.zoom - 1; i >= 0; i--) {
          //   if (zoomVisibilities[i]) {
          //     visibleIndices = Object.keys(zoomVisibilities[i]);
          //     break;
          //   }
          // }

          const coveredBoxes = [];
          const indexOfCovering = [];
          covers = {};
          for (const index of visibleIndices) {
            const marker = markers[index];
            const rect = marker.containerDiv.getBoundingClientRect();
            const left = rect.x;
            const top = rect.y;
            const right = left + rect.width;
            const bottom = top + rect.height;
            coveredBoxes.push([left, top, right, bottom]);
            indexOfCovering.push(index);
            covers[index] = [];
          }
          let i = -1;
          for (const marker of markers) {
            i++;
            if (covers[i]) continue;
            const rect = marker.containerDiv.getBoundingClientRect();
            const left = rect.x;
            const top = rect.y;
            const right = left + rect.width;
            const bottom = top + rect.height;
            let j = 0;
            let covered = false;
            for (const [l2, t2, r2, b2] of coveredBoxes) {
              if (left > r2 || right < l2 || top > b2 || bottom < t2) {
                // not touching
              } else {
                covered = true;
                covers[indexOfCovering[j]].push(i);
                break;
              }
              j++;
            }
            if (!covered) {
              coveredBoxes.push([left, top, right, bottom]);
              indexOfCovering.push(i);
              covers[i] = [];
            }
          }
          zoomVisibilities[map.zoom] = covers;
          applyVisibilities(covers);
          prevZoom = map.zoom;
        }

        const visibilityInterval = setInterval(() => {
          if (markers[0].containerDiv.getBoundingClientRect().width > 0) {
            clearInterval(visibilityInterval);
            updateVisibilities();
          }
        }, 10);
      }
    }

    if (initialMode === "gallery") {
      activateGallery();
    } else if (initialMode === "map") {
      activateMap();
    } else {
    }

    //  __                                                    __                        __      __
    // /  |                                                  /  |                      /  |    /  |
    // $$/  _____  ____    ______          _______   ______  $$ |  ______    _______  _$$ |_   $$/   ______   _______
    // /  |/     \/    \  /      \        /       | /      \ $$ | /      \  /       |/ $$   |  /  | /      \ /       \
    // $$ |$$$$$$ $$$$  |/$$$$$$  |      /$$$$$$$/ /$$$$$$  |$$ |/$$$$$$  |/$$$$$$$/ $$$$$$/   $$ |/$$$$$$  |$$$$$$$  |
    // $$ |$$ | $$ | $$ |$$ |  $$ |      $$      \ $$    $$ |$$ |$$    $$ |$$ |        $$ | __ $$ |$$ |  $$ |$$ |  $$ |
    // $$ |$$ | $$ | $$ |$$ \__$$ |       $$$$$$  |$$$$$$$$/ $$ |$$$$$$$$/ $$ \_____   $$ |/  |$$ |$$ \__$$ |$$ |  $$ |
    // $$ |$$ | $$ | $$ |$$    $$ |      /     $$/ $$       |$$ |$$       |$$       |  $$  $$/ $$ |$$    $$/ $$ |  $$ |
    // $$/ $$/  $$/  $$/  $$$$$$$ |      $$$$$$$/   $$$$$$$/ $$/  $$$$$$$/  $$$$$$$/    $$$$/  $$/  $$$$$$/  $$/   $$/
    //                   /  \__$$ |
    //                   $$    $$/
    //                    $$$$$$/

    function prevImage() {
      if (!openFileName) return;
      const newFilename = imageChanges[openFileName]["prev"];
      if (!newFilename) return;
      activateFullScreen(newFilename);
    }

    function nextImage() {
      if (!openFileName) return;
      const newFilename = imageChanges[openFileName]["next"];
      if (!newFilename) return;
      activateFullScreen(newFilename);
    }

    const minCardWidth = 160;
    const minCardHeight = 132;

    function maxWidthThatFits(spaceWidth, spaceHeight, width, height) {
      // assume full width
      const spaceAspect = spaceWidth / spaceHeight;
      const aspect = width / height;
      if (aspect > spaceAspect) {
        return spaceWidth;
      }
      return spaceHeight * aspect;
    }

    function bestImgWidth(filename) {
      const usableWidth = window.innerWidth - gutter * 2;
      const usableHeight = window.innerHeight - gutter * 2;
      const { width, height } = images[filename];
      // assume horizontal layout
      let widthIfHorizontal = maxWidthThatFits(
        usableWidth - minCardWidth,
        usableHeight,
        width,
        height
      );
      //asume vertical layout
      let widthIfVertical = maxWidthThatFits(
        usableWidth,
        usableHeight - minCardHeight,
        width,
        height
      );

      return [
        Math.max(widthIfHorizontal, widthIfVertical),
        widthIfHorizontal > widthIfVertical,
      ]; // is horizontal layout
    }

    function setCurrentImageWidthAndLayout() {
      const [bestWidth, isHorizontal] = bestImgWidth(openFileName);
      currentImageElement.style.width = bestWidth + "px";
      if (isHorizontal) {
        photoFullScreenElement.style.flexDirection = "row";
        imageInfoElement.style.maxWidth =
          window.innerWidth - gutter * 2 - bestWidth + "px";
      } else {
        photoFullScreenElement.style.flexDirection = "column";
        imageInfoElement.style.maxWidth = "none";
      }
    }

    function setImUrlQuery(filename) {
      var newurl = window.location.protocol + "//" + window.location.host;
      if (
        location.pathname == "/photo/map" ||
        location.pathname.startsWith("/photo/map/")
      ) {
        newurl += "/photo/map";
      } else {
        newurl += "/photo";
      }
      if (filename) {
        newurl += "/" + filename;
      }
      window.history.replaceState({}, null, newurl);
    }

    function activateFullScreen(filename) {
      // setOGImage(filename);
      if (!filename || !images[filename]) {
        document.title = "Photography | Blake Sanie";
        setImUrlQuery();
        fullScreenOpen = false;
        fullScreenElement.classList.remove("active");
        document.body.classList.remove("stop-scrolling");
        return;
      }
      openFileName = filename;
      setImUrlQuery(filename);
      if (!fullScreenOpen) {
        if (!fullScreenElement) {
          fullScreenElement = document.getElementById("fullScreen");
          photoFullScreenElement = document.getElementById("photoFullScreen");
          mapFullScreenElement = document.getElementById("mapFullScreen");
          selectedMapElement = document.getElementById("selectedMap");
          imageInfoElement = document.getElementById("imageInfo");
          prevElement = document.getElementById("prev");
          prevElement.addEventListener("click", prevImage);
          nextElement = document.getElementById("next");
          nextElement.addEventListener("click", nextImage);
          document
            .getElementById("exit")
            .addEventListener("click", activateFullScreen);
          imageNameElement = document.getElementById("imageName");
          metaDataElement = document.getElementById("metaData");
        }
        fullScreenOpen = true;
      }
      buildSelectedMap(filename);

      document.body.classList.add("stop-scrolling");

      // set prev and next blocks
      const { prev, next } = imageChanges[filename];
      // console.log("prev", prev, "next", next);
      const cleanName = decodeURIComponent(filename.replaceAll("--", "%"));
      imageNameElement.innerHTML = cleanName;
      document.title = cleanName + " | Photography | Blake Sanie";
      prevElement.style.display = prev ? "block" : "none";
      nextElement.style.display = next ? "block" : "none";

      // set full screen image
      if (currentImageElement) {
        currentImageElement.remove();
      }
      currentImageElement = document
        .getElementById(`fullScreen-${filename}`)
        .cloneNode(true);
      setCurrentImageWidthAndLayout();
      photoFullScreenElement.appendChild(currentImageElement);

      // set meta data
      metaDataElement.innerHTML = "";
      const captured = images[filename];
      // console.log("showcase image", filename, images[filename]);
      if (captured.shutter) {
        if (captured.shutter < 0) {
        }
        metaDataElement.innerHTML += `<div>${
          captured.shutter < 1
            ? `1/${Math.round(1 / captured.shutter)}`
            : captured.shutter
        }s</div>`;
      }
      if (captured.aperture) {
        metaDataElement.innerHTML += `<div>f/${
          Math.round(captured.aperture * 10) / 10
        }</div>`;
      }
      if (captured.iso) {
        metaDataElement.innerHTML += `<div>ISO ${captured.iso}</div>`;
      }
      if (captured.focalLength) {
        metaDataElement.innerHTML += `<div>${Math.round(
          captured.focalLength
        )}mm</div>`;
      }
      if (captured.camera) {
        let cam = captured.camera;
        // cam = cam.replace("SONY ILCE-7", "Sony A7");

        metaDataElement.innerHTML += `<div>${cam}</div>`;
      }
      if (captured.lens && !captured.lens.endsWith("mm")) {
        metaDataElement.innerHTML += `<div>${captured.lens}</div>`;
      }
      if (captured.latitude) {
        metaDataElement.innerHTML += `<div>GPS Below</div>`;
      }
      mapFullScreenElement.style.display = captured.latitude ? "block" : "none";
      fullScreenElement.classList.add("active");
    }

    window.addEventListener("resize", () => {
      if (fullScreenOpen) {
        setCurrentImageWidthAndLayout();
      }
    });

    //  __                            __                                            __
    // /  |                          /  |                                          /  |
    // $$ |   __   ______   __    __ $$ |____    ______    ______    ______    ____$$ |
    // $$ |  /  | /      \ /  |  /  |$$      \  /      \  /      \  /      \  /    $$ |
    // $$ |_/$$/ /$$$$$$  |$$ |  $$ |$$$$$$$  |/$$$$$$  | $$$$$$  |/$$$$$$  |/$$$$$$$ |
    // $$   $$<  $$    $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ | /    $$ |$$ |  $$/ $$ |  $$ |
    // $$$$$$  \ $$$$$$$$/ $$ \__$$ |$$ |__$$ |$$ \__$$ |/$$$$$$$ |$$ |      $$ \__$$ |
    // $$ | $$  |$$       |$$    $$ |$$    $$/ $$    $$/ $$    $$ |$$ |      $$    $$ |
    // $$/   $$/  $$$$$$$/  $$$$$$$ |$$$$$$$/   $$$$$$/   $$$$$$$/ $$/        $$$$$$$/
    //                     /  \__$$ |
    //                     $$    $$/
    //                      $$$$$$/

    function setKeyDown() {
      document.onkeydown = function (evt) {
        evt = evt || window.event;
        if (fullScreenOpen) {
          if (evt.key === "Escape" || evt.key === "Esc") {
            document.getElementById("exit").click();
          } else if (evt.key === "ArrowLeft") {
            clearInterval(blurInterval);
            prevImage();
          } else if (evt.key === "ArrowRight") {
            clearInterval(blurInterval);
            nextImage();
          } else if (evt.key === "ArrowDown") {
            fullScreenElement.scroll({
              top: fullScreenElement.scrollHeight,
              behavior: "smooth",
            });
          } else if (evt.key === "ArrowUp") {
            fullScreenElement.scroll({
              top: 0,
              behavior: "smooth",
            });
          }
        }
      };
    }

    setKeyDown();

    //                      __                        __                      __
    //                     /  |                      /  |                    /  |
    //   _______   ______  $$ |  ______    _______  _$$ |_     ______    ____$$ |       _____  ____    ______    ______
    //  /       | /      \ $$ | /      \  /       |/ $$   |   /      \  /    $$ |      /     \/    \  /      \  /      \
    // /$$$$$$$/ /$$$$$$  |$$ |/$$$$$$  |/$$$$$$$/ $$$$$$/   /$$$$$$  |/$$$$$$$ |      $$$$$$ $$$$  | $$$$$$  |/$$$$$$  |
    // $$      \ $$    $$ |$$ |$$    $$ |$$ |        $$ | __ $$    $$ |$$ |  $$ |      $$ | $$ | $$ | /    $$ |$$ |  $$ |
    //  $$$$$$  |$$$$$$$$/ $$ |$$$$$$$$/ $$ \_____   $$ |/  |$$$$$$$$/ $$ \__$$ |      $$ | $$ | $$ |/$$$$$$$ |$$ |__$$ |
    // /     $$/ $$       |$$ |$$       |$$       |  $$  $$/ $$       |$$    $$ |      $$ | $$ | $$ |$$    $$ |$$    $$/
    // $$$$$$$/   $$$$$$$/ $$/  $$$$$$$/  $$$$$$$/    $$$$/   $$$$$$$/  $$$$$$$/       $$/  $$/  $$/  $$$$$$$/ $$$$$$$/
    //                                                                                                         $$ |
    //                                                                                                         $$ |
    //                                                                                                         $$/

    let selectedMap;

    function buildSelectedMap(filename) {
      // if
      const { longitude, latitude } = images[filename];
      if (!longitude) {
        mapFullScreenElement.style.display = "none";
        return;
      } else {
        mapFullScreenElement.style.display = "block";
      }
      selectedMap = new google.maps.Map(selectedMapElement, {
        center: {
          lat: latitude,
          lng: longitude,
        },
        zoom: 16,
        zoomControl: true,
        zoomControlOptions: {
          position: google.maps.ControlPosition.RIGHT_CENTER,
        },
        streetViewControl: true,
        streetViewControlOptions: {
          position: google.maps.ControlPosition.RIGHT_CENTER,
        },
        fullscreenControl: true,
        fullscreenControlOptions: {
          position: google.maps.ControlPosition.RIGHT_CENTER,
        },
        rotateControl: true,
        rotateControlOptions: {
          position: google.maps.ControlPosition.RIGHT_CENTER,
        },
      });
      const marker = new google.maps.Marker({
        position: { lat: latitude, lng: longitude },
        map: selectedMap,
      });
    }

    //  _______    ______   __     __
    // /       \  /      \ /  \   /  |
    // $$$$$$$  | $$$$$$  |$$  \ /$$/
    // $$ |  $$ | /    $$ | $$  /$$/
    // $$ |  $$ |/$$$$$$$ |  $$ $$/
    // $$ |  $$ |$$    $$ |   $$$/
    // $$/   $$/  $$$$$$$/     $/

    document.getElementById("mapNavLink").addEventListener("click", (e) => {
      e.preventDefault();
      document.getElementById("mapButton").click();
    });

    document.getElementById("photoNavLink").addEventListener("click", (e) => {
      e.preventDefault();
      document.getElementById("galleryButton").click();
    });

    //   ______   ______
    // /      \ /      |
    // /$$$$$$  |$$$$$$/
    // $$ |__$$ |  $$ |
    // $$    $$ |  $$ |
    // $$$$$$$$ |  $$ |
    // $$ |  $$ | _$$ |_
    // $$ |  $$ |/ $$   |
    // $$/   $$/ $$$$$$/

    const script = document.createElement("script");
    script.addEventListener("load", loadModel);
    script.src =
      "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.js";
    document.head.appendChild(script);

    let modelSession;
    let tokenizer;
    let imageEmbeddings;
    const AITextField = document.querySelector("#AISearch > input");

    const advancedLabel = document.getElementById("advancedLabel");
    const AISearch = document.getElementById("AISearch");

    let advancedOpen = false;
    let textLastSearched;

    advancedLabel.addEventListener("click", () => {
      if (advancedOpen) {
        advancedLabel.innerHTML =
          "AI search via Zero-Shot Image Classification";
        AISearch.classList.add("minimized");
      } else {
        advancedLabel.innerHTML = "Close AI image search";
        AISearch.classList.remove("minimized");
      }
      advancedOpen = !advancedOpen;
    });

    async function loadModel() {
      const modelPath =
        "https://huggingface.co/rocca/openai-clip-js/resolve/main/clip-text-vit-32-uint8.onnx";
      // `https://huggingface.co/rocca/openai-clip-js/resolve/main/clip-image-vit-32-${quantized ? "uint8" : "float32"}.onnx

      //"https://huggingface.co/rocca/openai-clip-js/resolve/main/clip-text-vit-32-float32-int32.onnx";
      // modelSession = await ort.InferenceSession.create(modelPath, {
      //   executionProviders: ["wasm"],
      // });
      const [session, Tokenizer, imageEmb] = await Promise.all([
        ort.InferenceSession.create(modelPath, {
          executionProviders: ["wasm"],
        }),
        import("https://deno.land/x/clip_bpe@v0.0.6/mod.js"),
        // restore below line to fetch("/assets/imageEmbeddings.json"),
        fetch("/assets/imageEmbeddings.json"),
      ]);
      modelSession = session;
      tokenizer = new Tokenizer.default();
      imageEmbeddings = await imageEmb.json();
      // console.log("CLIP Model Loaded", modelSession, tokenizer);
      AITextField.removeAttribute("disabled");
      AITextField.setAttribute(
        "placeholder",
        'Model ready! Try any query, ex. "New York City Sunset"'
      );
    }

    async function getTextEmbedding(text) {
      let textTokens = tokenizer.encodeForCLIP(text);
      textTokens = Int32Array.from(textTokens);
      const feeds = { input: new ort.Tensor("int32", textTokens, [1, 77]) };
      const results = await modelSession.run(feeds);
      return results["output"].data;
    }

    async function searchByText(text) {
      const textEmbedding = await getTextEmbedding(text);
      const norm = Math.sqrt(
        textEmbedding.reduce((acc, curr) => {
          return acc + curr * curr;
        }, 0)
      );
      for (let i = 0; i < textEmbedding.length; i++) {
        textEmbedding[i] /= norm;
      }
      // console.log("text embedding", textEmbedding);
      const similarities = {};
      for (const [name, embedding] of Object.entries(imageEmbeddings)) {
        if (!images[name]) {
          continue;
        }
        const similarity = embedding.reduce((acc, curr, i) => {
          return acc + curr * textEmbedding[i];
        }, 0);
        similarities[name] = similarity;
      }
      const ranking = Object.entries(similarities).sort(function (
        first,
        second
      ) {
        return second[1] - first[1];
      });
      const indices = {};
      for (let i = 0; i < ranking.length; i++) {
        const name = ranking[i][0];
        indices[name] = i;
      }
      // console.log(
      //   "ranking",
      //   ranking.map((x) => x[0]),
      //   ranking
      // );
      orderImageElementsByRanking(indices);
      setImageOrder();
      // shuffleImgElements();
      // msnry = undefined;
      activateGallery(true);
    }

    async function beginSearchByText() {
      const text = AITextField.value.trim().toLowerCase();
      if (advancedOpen && text !== textLastSearched) {
        textLastSearched = text;
        await searchByText(textLastSearched);
      }
    }

    AITextField.addEventListener("blur", beginSearchByText);
    AITextField.addEventListener("change", beginSearchByText);
    AITextField.addEventListener("focusout", beginSearchByText);
    AITextField.addEventListener("keydown", async (e) => {
      if (e.key === "Enter") {
        await beginSearchByText();
      }
    });

    function swapElements(nodeA, nodeB) {
      const parentA = nodeA.parentNode;
      const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;
      // Move `nodeA` to before the `nodeB`
      nodeB.parentNode.insertBefore(nodeA, nodeB);
      // Move `nodeB` to before the sibling of `nodeA`
      parentA.insertBefore(nodeB, siblingA);
    }

    function orderImageElementsByRanking(indices) {
      // console.log("indices", indices);
      for (var i = 0; i < galleryContainer.children.length; i++) {
        const child = galleryContainer.children[i];
        const name = child.getAttribute("name");
        const index = indices[name];
        if (i == index) {
          // child.style.top = ''
          // child.style.left = ''
          // child.removeAttribute("style");
          continue;
        }
        const target = galleryContainer.children[index];
        if (!target) {
          // console.log(
          //   "want to swap with element",
          //   index,
          //   name,
          //   "but len is",
          //   galleryContainer.children.length
          // );
        }
        swapElements(child, target);
        i--;
      }
    }

    //   ______    ______
    //  /      \  /      \
    // /$$$$$$  |/$$$$$$  |
    // $$ |  $$ |$$ | _$$/
    // $$ |  $$ |$$ |/    |
    // $$ |  $$ |$$ |$$$$ |
    // $$ \__$$ |$$ \__$$ |
    // $$    $$/ $$    $$/
    //  $$$$$$/   $$$$$$/

    // console.log("default OG info", defaultOGInfo, title, description);

    // // const originalOGImagePath = document
    // //   .querySelector('meta[property="og:image"]')
    // //   .getAttribute("content");
    // // const originalOGImageType = document
    // //   .querySelector('meta[property="og:image:type"]')
    // //   .getAttribute("content");
    // // const originalOGImageWidth = document
    // //   .querySelector('meta[property="og:image:width"]')
    // //   .getAttribute("content");
    // // const originalOGImageHeight = document
    // //   .querySelector('meta[property="og:image:height"]')
    // //   .getAttribute("content");
    // // const originalOGImageDescription = document
    // //   .querySelector('meta[property="og:image:alt"]')
    // //   .getAttribute("content");
    // // const originalTitle = title;

    // function setMetaTags(thumb, alt, title, description, width, height) {
    //   alt = alt || "";

    //   document.title = title;
    //   document
    //     .querySelector('meta[name="description"]')
    //     .setAttribute("content", description);

    //   document
    //     .querySelector('meta[property="og:title"]')
    //     .setAttribute("content", title);
    //   document
    //     .querySelector('meta[property="og:description"]')
    //     .setAttribute("content", description);
    //   document
    //     .querySelector('meta[property="og:image"]')
    //     .setAttribute("content", thumb);
    //   document
    //     .querySelector('meta[property="og:image:url"]')
    //     .setAttribute("content", thumb);
    //   document
    //     .querySelector('meta[property="og:image:alt"]')
    //     .setAttribute("content", alt);
    //   document
    //     .querySelector('meta[property="og:image:type"]')
    //     .setAttribute("content", thumb.split(".").pop());
    //   document
    //     .querySelector('meta[property="og:image:width"]')
    //     .setAttribute("content", width);
    //   document
    //     .querySelector('meta[property="og:image:height"]')
    //     .setAttribute("content", height);

    //   document
    //     .querySelector('meta[name="twitter:title"]')
    //     .setAttribute("content", title);
    //   document
    //     .querySelector('meta[name="twitter:description"]')
    //     .setAttribute("content", description);
    //   document
    //     .querySelector('meta[name="twitter:image"]')
    //     .setAttribute("content", thumb);
    //   document
    //     .querySelector('meta[name="twitter:image:alt"]')
    //     .setAttribute("content", alt);
    // }

    // function setOGImage(filename) {
    //   const image = images[filename];
    //   if (!filename || !image) {
    //     return setMetaTags(
    //       defaultOGInfo.image,
    //       defaultOGInfo.imageAlt,
    //       title,
    //       defaultOGInfo.description,
    //       defaultOGInfo.width,
    //       defaultOGInfo.height
    //     );
    //   }
    //   const cleanName = decodeURIComponent(filename.replaceAll("--", "%"));
    //   console.log("image set tags for", image);
    //   setMetaTags(
    //     image.ogImg,
    //     cleanName,
    //     cleanName + " | " + title,
    //     cleanName + " | " + description,
    //     ogWidth,
    //     Math.round((ogWidth / image.width) * image.height)
    //   );
    // }
  </script>
</HeaderAndFooter>
